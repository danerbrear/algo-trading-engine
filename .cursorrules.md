# Cursor Rules for LSTM POC Project

## Table of Contents
1. [Agentic Standards](#agentic-standards)
2. [Project Structure](#project-structure)
3. [Value Object (VO) Rules](#value-object-vo-rules)
4. [Data Transfer Object (DTO) Rules](#data-transfer-object-dto-rules)
5. [Feature Implementation Guidelines](#feature-implementation-guidelines)

---

## Agentic Standards

### Core Principles
- The codebase should not have deprecated functions. Every function should be used and should migrate all functionality to use new functions.
- Don't make things backward compatible. Instead update the usages to use new logic.
- We should use DTO's and VO's instead of Dicts
- When a new function is created, unit tests should be made.
- When running any commands, make sure we are in the venv
- Any new libraries added should be added to requirements.txt and are compatible
- Always make sure that all of the imports added are used

---

## Project Structure

### Root Directory Structure

#### Core Directory Organization
- **`src/`** - Main source code directory containing all Python packages
- **`data_cache/`** - Cached market data organized by data type
- **`predictions/`** - Output files for daily predictions
- **`venv/`** - Python virtual environment (excluded from git)
- **`__pycache__/`** - Python cache files (excluded from git)

#### Configuration and Documentation
- **Root level config files** - Project-wide configuration and setup
- **Documentation files** - README, usage guides, and documentation

### src/ Package Structure

#### Package Organization Principles
- Each folder in `src/` should be its own Python package
- Each package should have an `__init__.py` file
- Each package should have a `main.py` that can be run with `python -m src.<package>.main`
- Packages should be focused on a single domain or responsibility

#### Package Structure Guidelines

##### 1. **model/** - Machine Learning Models
- **Purpose**: Core ML models and training logic
- **Structure**:
  - `main.py` - Entry point for training and evaluation
  - Model implementation files (one per model type)
  - Configuration files for model settings
  - Utility files for visualization and tracking
  - Feature engineering modules

##### 2. **common/** - Shared Utilities
- **Purpose**: Reusable components and utilities
- **Structure**:
  - Core utility modules
  - Shared data models and DTOs
  - Common functions and helpers
  - Subpackages for specialized functionality (e.g., `cache/`)

##### 3. **prediction/** - Prediction Pipeline
- **Purpose**: Making predictions on current market data
- **Structure**:
  - Main prediction script
  - Prediction-specific models and utilities
  - Configuration management
  - Documentation for prediction components

##### 4. **strategies/** - Trading Strategies
- **Purpose**: Implementation of trading strategies
- **Structure**:
  - One file per strategy implementation
  - Strategy-specific utilities and helpers
  - Common strategy interfaces or base classes

##### 5. **backtest/** - Backtesting Framework
- **Purpose**: Strategy backtesting and performance analysis
- **Structure**:
  - Main backtesting entry point
  - Backtesting data models and utilities
  - Performance analysis tools

### Data Directory Structure

#### data_cache/ Organization
- **Organize by data type**: Each data type gets its own subdirectory
- **Examples**:
  - `stocks/` - Stock price data cache
  - `options/` - Options chain data cache
  - `treasury/` - Treasury yield data cache
  - `calendar/` - Calendar data cache
- **Structure within each subdirectory**:
  - Use consistent file naming patterns
  - Organize by date, ticker, or other logical grouping
  - Include metadata files for cache management

#### predictions/ Organization
- **File naming convention**: Include ticker symbol and date
- **Structure**:
  - One file per prediction run
  - Consistent format across all prediction files
  - Include timestamp and metadata in filename

### Directory Organization Rules

#### 1. **Single Responsibility per Directory**
- Each directory should have a clear, single purpose
- Avoid mixing different types of functionality in the same directory
- Use subdirectories to organize related functionality

#### 2. **Logical Grouping**
- Group related files together in subdirectories
- Use descriptive directory names that indicate purpose
- Maintain consistent naming conventions across directories

#### 3. **Hierarchical Organization**
- Use a clear hierarchy: root → main directories → subdirectories → files
- Keep the hierarchy shallow (max 3-4 levels deep)
- Use subdirectories to organize complex packages

#### 4. **Scalability Considerations**
- Design directory structure to accommodate growth
- Use subdirectories to prevent directories from becoming too large
- Plan for future additions and modifications

### Package Dependencies and Relationships

#### Dependency Flow
- **common/** - Base utilities used by all other packages
- **model/** - Depends on common/, provides ML functionality
- **prediction/** - Depends on model/ and common/, provides prediction pipeline
- **strategies/** - Depends on common/, implements trading strategies
- **backtest/** - Depends on strategies/ and common/, provides backtesting

#### Import Structure Guidelines
- Use relative imports within packages
- Use absolute imports for cross-package dependencies
- Maintain clear dependency boundaries between packages

### Configuration and Environment Structure

#### Configuration Organization
- **Root level**: Project-wide configuration files
- **Package level**: Package-specific configuration in each package
- **Environment**: Use `.env` files for sensitive data
- **Documentation**: Include configuration guides and examples

#### Environment Setup
- **Virtual environment**: Use `venv/` for Python environment
- **Dependencies**: Use `requirements.txt` for dependency management
- **Setup scripts**: Include environment initialization scripts

### Data Management Structure

#### Caching Strategy
- **Organize by data type**: Separate directories for different data types
- **Consistent naming**: Use consistent file naming patterns
- **Metadata management**: Include metadata files for cache management
- **Cleanup strategies**: Implement cache invalidation and cleanup

#### Output Organization
- **Predictions**: Timestamped files with consistent naming
- **Results**: Organize by date, strategy, or other logical grouping
- **Logs**: Separate logging from output data

### Testing Structure

#### Test Organization
- **Mirror package structure**: Create `tests/` directory that mirrors `src/` structure
- **Test naming**: Use `test_` prefix for test files
- **Test organization**: Group tests by functionality and package

### Documentation Structure

#### Documentation Organization
- **Root level**: Main project documentation
- **Package level**: Package-specific documentation
- **Configuration**: Documentation for configuration options
- **Usage guides**: Step-by-step guides for common tasks

### Version Control Structure

#### Git Organization
- **Ignore patterns**: Exclude virtual environments, cache files, and system files
- **Branch strategy**: Use feature branches for development
- **Commit organization**: Group related changes in logical commits

### Performance and Maintenance

#### Directory Optimization
- **Keep directories focused**: Avoid overly large directories
- **Use subdirectories**: Break down large directories into logical subdirectories
- **Consistent patterns**: Use consistent organization patterns across the project

#### Maintenance Considerations
- **Easy navigation**: Structure should be intuitive to navigate
- **Clear boundaries**: Clear separation between different types of functionality
- **Extensibility**: Structure should accommodate future additions

### Security and Best Practices

#### Directory Security
- **Sensitive data**: Keep sensitive data in appropriate directories
- **Access control**: Use appropriate file permissions
- **Environment separation**: Separate development and production configurations

#### Data Organization
- **Input validation**: Validate data at directory boundaries
- **Error handling**: Implement proper error handling for file operations
- **Backup strategies**: Plan for data backup and recovery

---

## Value Object (VO) Rules

### Core Principles

#### 1. **Immutability**
- Value Objects should be immutable after creation
- Use `@dataclass(frozen=True)` or `@property` decorators
- Prevent modification of internal state
- Return new instances for any "changes"

#### 2. **Value-Based Equality**
- Two Value Objects are equal if all their attributes are equal
- Implement `__eq__` method based on all attributes
- Use `__hash__` for hashable collections
- Consider using `@dataclass` with `eq=True`

#### 3. **Self-Contained Behavior**
- Value Objects should contain their own validation logic
- Include business rules and constraints
- Provide methods for common operations
- Encapsulate related data and behavior

#### 4. **Domain Representation**
- Represent real-world domain concepts
- Use descriptive, domain-specific names
- Avoid technical implementation details
- Focus on business meaning, not data storage

### Naming Conventions

#### 5. **Descriptive Names**
- Use domain terminology, not technical terms
- Examples: `MarketState`, `TradingSignal`, `PriceRange`
- Avoid generic names like `Data`, `Info`, `Object`
- Use nouns that represent domain concepts

#### 6. **Consistent Naming**
- Use PascalCase for class names
- Use snake_case for attributes and methods
- Use descriptive attribute names
- Follow domain language conventions

### Structure and Organization

#### 7. **Location in Project**
- Place Value Objects in `src/common/models.py` for shared domain objects
- Create package-specific Value Objects in their respective packages
- Use `src/model/` for model-specific Value Objects
- Use `src/strategies/` for strategy-specific Value Objects

#### 8. **Package Organization**
```python
# src/common/models.py - Shared Value Objects
class MarketState:
    """Represents a market state identified by HMM"""
    
class TradingSignal:
    """Represents a trading signal with confidence"""
    
class PriceRange:
    """Represents a price range with validation"""
```

### Implementation Guidelines

#### 9. **Constructor Design**
- Validate all input parameters
- Use type hints for all parameters
- Provide clear error messages for invalid data
- Consider using factory methods for complex creation

#### 10. **Validation Rules**
- Validate data at construction time
- Use domain-specific validation rules
- Provide meaningful error messages
- Consider using `pydantic` for complex validation

#### 11. **Method Design**
- Keep methods focused and single-purpose
- Return new instances for "modifications"
- Use descriptive method names
- Include proper error handling

### Domain-Specific Examples

#### 12. **Market State Value Objects**
```python
from enum import Enum
from dataclasses import dataclass
from typing import Optional
from decimal import Decimal

class MarketStateType(Enum):
    LOW_VOLATILITY_UPTREND = "low_volatility_uptrend"
    MOMENTUM_UPTREND = "momentum_uptrend"
    CONSOLIDATION = "consolidation"
    HIGH_VOLATILITY_DOWNTREND = "high_volatility_downtrend"
    HIGH_VOLATILITY_RALLY = "high_volatility_rally"

@dataclass(frozen=True)
class MarketState:
    """Represents a market state with characteristics"""
    state_type: MarketStateType
    volatility: Decimal
    average_return: Decimal
    confidence: Decimal
    
    def __post_init__(self):
        if not 0 <= self.confidence <= 1:
            raise ValueError("Confidence must be between 0 and 1")
        if self.volatility < 0:
            raise ValueError("Volatility cannot be negative")
```

#### 13. **Trading Signal Value Objects**
```python
from enum import Enum
from dataclasses import dataclass
from decimal import Decimal
from typing import Optional

class SignalType(Enum):
    HOLD = "hold"
    CALL_CREDIT_SPREAD = "call_credit_spread"
    PUT_CREDIT_SPREAD = "put_credit_spread"

@dataclass(frozen=True)
class TradingSignal:
    """Represents a trading signal with strategy and confidence"""
    signal_type: SignalType
    confidence: Decimal
    ticker: str
    expiration_date: Optional[str] = None
    strike_prices: Optional[tuple[Decimal, Decimal]] = None
    
    def __post_init__(self):
        if not 0 <= self.confidence <= 1:
            raise ValueError("Confidence must be between 0 and 1")
        if self.signal_type != SignalType.HOLD and not self.expiration_date:
            raise ValueError("Expiration date required for option strategies")
    
    def is_option_strategy(self) -> bool:
        return self.signal_type in [SignalType.CALL_CREDIT_SPREAD, SignalType.PUT_CREDIT_SPREAD]
```

#### 14. **Price and Financial Value Objects**
```python
from dataclasses import dataclass
from decimal import Decimal
from typing import Optional

@dataclass(frozen=True)
class PriceRange:
    """Represents a price range with validation"""
    low: Decimal
    high: Decimal
    
    def __post_init__(self):
        if self.low > self.high:
            raise ValueError("Low price cannot be greater than high price")
        if self.low < 0:
            raise ValueError("Price cannot be negative")
    
    def contains(self, price: Decimal) -> bool:
        return self.low <= price <= self.high
    
    def spread(self) -> Decimal:
        return self.high - self.low

@dataclass(frozen=True)
class Volatility:
    """Represents volatility with validation"""
    value: Decimal
    period: int  # days
    
    def __post_init__(self):
        if self.value < 0:
            raise ValueError("Volatility cannot be negative")
        if self.period <= 0:
            raise ValueError("Period must be positive")
    
    def is_high(self) -> bool:
        return self.value > Decimal('0.3')  # 30% threshold
    
    def is_low(self) -> bool:
        return self.value < Decimal('0.1')  # 10% threshold
```

### Usage Patterns

#### 15. **Creation Patterns**
```python
# Factory method for complex creation
class MarketStateFactory:
    @staticmethod
    def create_from_hmm_output(state_id: int, confidence: float) -> MarketState:
        state_map = {
            0: MarketStateType.LOW_VOLATILITY_UPTREND,
            1: MarketStateType.MOMENTUM_UPTREND,
            # ... other mappings
        }
        return MarketState(
            state_type=state_map[state_id],
            confidence=Decimal(str(confidence)),
            # ... other parameters
        )
```

#### 16. **Collection Patterns**
```python
from typing import List

@dataclass(frozen=True)
class PredictionResult:
    """Collection of predictions for multiple time periods"""
    predictions: List[TradingSignal]
    market_state: MarketState
    timestamp: str
    
    def __post_init__(self):
        if not self.predictions:
            raise ValueError("Must have at least one prediction")
    
    def high_confidence_signals(self, threshold: Decimal = Decimal('0.7')) -> List[TradingSignal]:
        return [signal for signal in self.predictions if signal.confidence >= threshold]
```

### Validation and Error Handling

#### 17. **Validation Strategies**
- Use `__post_init__` for validation in dataclasses
- Provide clear, domain-specific error messages
- Validate business rules, not just data types
- Consider using custom exceptions for domain errors

#### 18. **Error Messages**
```python
class DomainError(Exception):
    """Base exception for domain-specific errors"""
    pass

class InvalidMarketStateError(DomainError):
    """Raised when market state is invalid"""
    pass

class InvalidTradingSignalError(DomainError):
    """Raised when trading signal is invalid"""
    pass
```

### Performance Considerations

#### 19. **Memory Efficiency**
- Use `@dataclass(frozen=True)` for immutability
- Consider using `__slots__` for memory optimization
- Use appropriate data types (Decimal for financial calculations)
- Avoid unnecessary object creation

#### 20. **Caching and Hashing**
- Implement `__hash__` for hashable collections
- Use Value Objects as dictionary keys when appropriate
- Consider caching frequently used Value Objects
- Use `__eq__` for value-based equality

### Testing Guidelines

#### 21. **Value Object Testing**
- Test all validation rules
- Test equality and hash methods
- Test business logic methods
- Test edge cases and boundary conditions
- Use factories for creating test data

#### 22. **Test Examples**
```python
def test_market_state_validation():
    # Test valid creation
    state = MarketState(
        state_type=MarketStateType.LOW_VOLATILITY_UPTREND,
        volatility=Decimal('0.15'),
        average_return=Decimal('0.02'),
        confidence=Decimal('0.8')
    )
    assert state.confidence == Decimal('0.8')
    
    # Test invalid confidence
    with pytest.raises(ValueError, match="Confidence must be between 0 and 1"):
        MarketState(
            state_type=MarketStateType.LOW_VOLATILITY_UPTREND,
            volatility=Decimal('0.15'),
            average_return=Decimal('0.02'),
            confidence=Decimal('1.5')  # Invalid
        )
```

### Integration with Other Patterns

#### 23. **DTO Integration**
- Convert Value Objects to DTOs for external communication
- Convert DTOs to Value Objects for domain processing
- Use mapping functions for conversions
- Maintain domain integrity during conversions

#### 24. **Repository Integration**
- Use Value Objects as parameters and return types
- Avoid exposing internal data structures
- Maintain domain boundaries
- Use Value Objects for query criteria

### Best Practices

#### 25. **Domain Focus**
- Keep Value Objects focused on domain concepts
- Avoid technical implementation details
- Use domain language in names and methods
- Represent business rules, not technical constraints

#### 26. **Composition Over Inheritance**
- Prefer composition for complex Value Objects
- Use simple inheritance for related concepts
- Keep inheritance hierarchies shallow
- Focus on behavior, not just data

#### 27. **Documentation**
- Document business rules and constraints
- Include examples of valid and invalid usage
- Document domain-specific methods
- Use docstrings for complex Value Objects

---

## Data Transfer Object (DTO) Rules

### Core Principles

#### 1. **Single Responsibility**
- DTOs should have one clear purpose: transferring data between layers
- Avoid mixing business logic with data transfer concerns
- Keep DTOs focused on data representation only

#### 2. **Immutability**
- Make DTOs immutable when possible (use `readonly` properties in TypeScript/C#)
- Prefer constructor-based initialization over property setters
- This prevents accidental modifications during data transfer

#### 3. **Validation**
- Validate data at the boundaries (API endpoints, service layer entry points)
- Use validation attributes/decorators for input DTOs
- Return validation errors as part of the response, not exceptions

### Naming Conventions

#### 4. **Consistent Naming**
- Use descriptive, domain-specific names
- Follow language conventions:
  - **C#/Java**: `UserDto`, `CreateUserRequest`, `UserResponse`
  - **TypeScript**: `UserDTO`, `CreateUserRequest`, `UserResponse`
  - **Python**: `UserDTO`, `CreateUserRequest`, `UserResponse`
- Suffix with purpose: `Request`, `Response`, `Command`, `Query`

#### 5. **Clear Intent**
- Request DTOs: `CreateUserRequest`, `UpdateUserRequest`
- Response DTOs: `UserResponse`, `UserListResponse`
- Query DTOs: `UserSearchQuery`, `UserFilterRequest`
- Command DTOs: `CreateUserCommand`, `DeleteUserCommand`

### Structure Guidelines

#### 6. **Flat Structure**
- Prefer flat structures over deeply nested objects
- Avoid circular references
- Use composition over inheritance for DTOs

#### 7. **Property Naming**
- Use clear, descriptive property names
- Follow camelCase for JSON serialization
- Use consistent naming across related DTOs

#### 8. **Data Types**
- Use primitive types when possible
- Avoid complex objects in DTOs unless necessary
- Use enums for fixed sets of values
- Use nullable types appropriately

### Best Practices

#### 9. **Separation of Concerns**
- Keep DTOs separate from domain entities
- Don't expose internal implementation details
- Use mapping libraries (AutoMapper, MapStruct) for conversions

#### 10. **Versioning**
- Include version information in DTOs when needed
- Use semantic versioning for API changes
- Consider backward compatibility

#### 11. **Documentation**
- Document all DTO properties with clear descriptions
- Include examples for complex DTOs

#### 12. **Error Handling**
- Include error information in response DTOs
- Use consistent error response structures
- Provide meaningful error messages

### Common Patterns

#### 13. **Request/Response Pattern**
```typescript
// Request DTO
interface CreateUserRequest {
  readonly email: string;
  readonly name: string;
  readonly age?: number;
}

// Response DTO
interface UserResponse {
  readonly id: string;
  readonly email: string;
  readonly name: string;
  readonly age?: number;
  readonly createdAt: Date;
}
```

#### 14. **Pagination Pattern**
```typescript
interface PaginatedResponse<T> {
  readonly data: T[];
  readonly totalCount: number;
  readonly pageNumber: number;
  readonly pageSize: number;
  readonly totalPages: number;
}
```

#### 15. **Filter/Search Pattern**
```typescript
interface UserSearchRequest {
  readonly query?: string;
  readonly filters?: {
    readonly ageRange?: { min: number; max: number };
    readonly status?: UserStatus[];
  };
  readonly sortBy?: string;
  readonly sortOrder?: 'asc' | 'desc';
  readonly pageNumber: number;
  readonly pageSize: number;
}
```

### Anti-Patterns to Avoid

#### 16. **Don't Do This**
- ❌ Mixing business logic in DTOs
- ❌ Using DTOs as domain entities
- ❌ Exposing internal database fields
- ❌ Creating overly complex nested structures
- ❌ Using DTOs for internal communication
- ❌ Ignoring validation at boundaries

#### 17. **Security Considerations**
- Never expose sensitive data in DTOs
- Sanitize input data
- Use DTOs to control what data is exposed
- Validate all inputs thoroughly

### Language-Specific Guidelines

#### 18. **TypeScript/JavaScript**
```typescript
// Use interfaces for DTOs
interface UserDTO {
  readonly id: string;
  readonly email: string;
  readonly name: string;
}

// Use type unions for responses
type ApiResponse<T> = 
  | { success: true; data: T }
  | { success: false; error: string };
```

#### 19. **C#**
```csharp
public record CreateUserRequest(
    string Email,
    string Name,
    int? Age = null
);

public record UserResponse(
    string Id,
    string Email,
    string Name,
    int? Age,
    DateTime CreatedAt
);
```

#### 20. **Python**
```python
from dataclasses import dataclass
from typing import Optional
from datetime import datetime

@dataclass(frozen=True)
class CreateUserRequest:
    email: str
    name: str
    age: Optional[int] = None

@dataclass(frozen=True)
class UserResponse:
    id: str
    email: str
    name: str
    age: Optional[int]
    created_at: datetime
```

### Testing Guidelines

#### 21. **DTO Testing**
- Test DTO serialization/deserialization
- Validate mapping between DTOs and domain objects
- Test edge cases and boundary conditions
- Use factories for creating test DTOs

#### 22. **Validation Testing**
- Test all validation rules
- Test both valid and invalid inputs
- Test boundary conditions
- Mock external dependencies

### Performance Considerations

#### 23. **Optimization**
- Keep DTOs lightweight
- Avoid unnecessary properties
- Use lazy loading for large datasets
- Consider using projection queries for large objects

#### 24. **Caching**
- DTOs should be cacheable when appropriate
- Use appropriate cache keys
- Consider cache invalidation strategies
- Document caching behavior

---

## Feature Implementation Guidelines

### Moving Average Velocity/Elasticity Analysis

#### Analysis Goals
- What is the elasticity/velocity (short term ma / longer term ma) that best signals a period of upward trend?
    - The best solution should be determined by percentage times a signal produces a up trend of SPY of at least 3 days
- What is the elasticity/velocity (short term ma / longer term ma) that best signals a period of downward trend?
    - The best solution should be determined by percentage times a signal produces a down trend of SPY of at least 3 days

#### Notes
- When tracking return for SPY, note that a downward movement can still indicate a larger upward/downward trend

#### Constraints
- The only dependency should be on data retrieval classes
- The output should be a short term MA and a longer term MA for upward swings and a short term MA and longer term MA for downward swings
- Don't consider upward/downward trends longer than 60 days
- Only analyze the most recent 6 months of data
- Include new files in a subfolder of /analysis
- **Focus purely on moving average analysis from SPY price changes**
- **No trading strategy, position management, or actual trades**
- **Only use daily close prices for SPY - no intraday or OHLC data needed**

#### Output
- The output should be the best two Moving Averages selected for both upward and downward trends

### Volume Trading Backtest Feature

#### Feature Description
Prevent trades when volume is less than 10 for an option contract when backtesting any strategy.

#### Overview
This feature adds volume validation to the backtesting system to ensure that only options with sufficient liquidity (volume >= 10) are considered for trading. This improves the realism of backtests by avoiding illiquid options that would be difficult to trade in real market conditions.

#### Key Design Principles
1. **Strategy Responsibility**: Strategies handle data fetching and ensure volume data is available in options
2. **BacktestEngine Validation**: BacktestEngine validates volume requirements before adding positions
3. **Separation of Concerns**: Data fetching is handled by Strategy, validation by BacktestEngine

#### Implementation Components
- `VolumeValidator` class with static methods
- `validate_option_volume(option: Option, min_volume: int = 10) -> bool`
- `validate_spread_volume(spread_options: list[Option], min_volume: int = 10) -> bool`
- `get_volume_status(option: Option) -> dict` for detailed volume information
- `VolumeConfig` DTO with configurable minimum volume
- `VolumeStats` DTO for tracking volume validation statistics

#### Success Criteria
1. **Separation of Concerns**: Data fetching handled by Strategy, validation by BacktestEngine
2. **Strategy Responsibility**: Strategies ensure volume data is available before creating positions
3. **BacktestEngine Validation**: BacktestEngine validates volume requirements before adding positions
4. **Volume Validation**: All option trades are validated for minimum volume (>= 10)
5. **Statistics Tracking**: Volume rejection statistics are tracked and reported
6. **Configuration**: Volume thresholds are configurable via BacktestEngine constructor
7. **Backward Compatibility**: Existing backtests continue to work with volume validation disabled
8. **Performance**: Volume validation adds minimal overhead to backtest execution
9. **Logging**: Clear logging of volume validation decisions for debugging

### Enhanced Current Date Volume Validation

#### Feature Description
Enhance the volume validation system to use current date volume data for position closures instead of stored entry date volume data. This ensures both opening and closing positions validate against current market conditions for more realistic backtesting.

#### Overview
Currently, the volume validation system has an inconsistency:
- **Position Opening**: Uses current date volume data (realistic)
- **Position Closing**: Uses entry date volume data (unrealistic)

This enhancement makes both opening and closing positions validate against current market conditions, providing more accurate liquidity assessment and realistic backtesting results.

#### Key Design Principles
1. **Consistent Validation**: Both opening and closing positions validate against current market conditions
2. **Accurate Liquidity Assessment**: Reflects real market conditions at closure time
3. **Better Risk Management**: Prevents closures when current market conditions are unfavorable
4. **Realistic Backtesting**: More accurately simulates real trading conditions
5. **Separation of Concerns**: Data fetching handled by Strategy, validation by BacktestEngine
6. **Efficient Implementation**: Pass volume data as parameters to avoid redundant API calls

#### Implementation Components
- `get_current_volumes_for_position()` method in strategy to fetch volume data for all options in a position
- Enhanced `_remove_position()` method to accept `current_volumes: list[int]` parameter
- Updated volume validation logic to use passed current volume data
- Comprehensive testing for current date vs. entry date validation

#### Success Criteria
1. **Consistent Validation**: Both opening and closing positions validate against current market conditions
2. **Accurate Liquidity Assessment**: Position closures reflect real market conditions at closure time
3. **Better Risk Management**: Prevents closures when current market conditions are unfavorable
4. **Realistic Backtesting**: More accurately simulates real trading conditions
5. **Performance**: Enhanced validation adds minimal overhead to backtest execution
6. **Error Handling**: Graceful handling of API failures during volume data fetching in strategy
7. **Backward Compatibility**: Existing functionality continues to work with enhanced validation
8. **Comprehensive Testing**: Thorough testing of current date vs. entry date validation
9. **Documentation**: Clear documentation explaining the enhancement and its benefits
10. **Efficient Implementation**: Parameter passing approach avoids redundant API calls
11. **Clean Separation**: Data fetching in Strategy, validation in BacktestEngine

### Interactive Strategy Recommendations

#### Feature Description
Add a class under `src/prediction/` that executes a `Strategy` instance to produce actionable trade recommendations for the current market day, prompts the user to accept or reject proposed trades, persists accepted decisions to JSON, and, when a position is already open, produces a recommendation on whether to close it.

#### Overview
This feature connects live prediction outputs to an actionable, auditable decision flow:
- Execute a `Strategy` (e.g., `CreditSpreadStrategy`) against current data to propose a single new position recommendation when appropriate.
- If a recommendation is produced, interactively prompt the user to accept or reject it.
- Persist accepted decisions as immutable JSON records under `predictions/` for traceability.
- Detect any currently open position(s) from the decision store and recommend whether to close them (profit target, stop loss, holding period, or expiration proximity), using current market data and existing logic (including current-date volume validation where available).

#### Key Principles
- Single responsibility per module (storage, recommendation, CLI wiring)
- DTOs/VOs instead of raw dicts
- No backward-compat shims; update call sites as needed
- Unit tests for all new functions/classes

#### Implementation Components
- `ProposedPositionDTO` (DTO): represents a full proposed position
- `DecisionRecord` (DTO): immutable record capturing the decision outcome
- `JsonDecisionStore` (class): append-only JSON storage and retrieval
- `InteractiveStrategyRecommender` (class): orchestrates open/close flows
- CLI entrypoint for running the recommender end-to-end

#### Success Criteria
1. A new class under `src/prediction/` can execute a `Strategy` and produce a proposed position when appropriate.
2. The user is prompted to accept or reject proposed positions; accepted ones are stored as immutable JSON decision records.
3. Existing open positions are detected and a close recommendation is produced with rationale; accepted closures update the JSON record.
4. DTOs are used for proposals and decisions; reuse existing VOs (`Option`, `StrategyType`, and runtime `Position`) and avoid duplicate leg/open-position VOs.
5. Tests cover storage, open recommendation, close recommendation, and non-interactive flows.

#### Risk Mitigation
- Non-interactive environments: provide `--yes` flag to auto-accept recommendations (useful for batch runs). Default is safe reject.
- Data availability: if current option chain is unavailable, fall back to generic recommendations without persisting.
- Volume validation: closure decisions should use current-date volume when available to avoid stale liquidity assumptions.
- Idempotency: decision store appends are append-only; duplicates guarded via deterministic IDs (hash of symbol+timestamp+legs).
